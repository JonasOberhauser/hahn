(******************************************************************************)
(** * Lemmas about traces (finite or infinite sequences) *)
(******************************************************************************)

Require Import HahnBase HahnList.
Require Import Omega.

Set Implicit Arguments.

(** Finite or infinite traces of [A] elements. *)

Inductive trace (A : Type) : Type :=
| trace_fin (l : list A)
| trace_inf (fl : nat -> A).

Definition trace_seq A (t t' : trace A) :=
  match t, t' with
  | trace_fin l, trace_fin l' => trace_fin (l ++ l')
  | trace_fin l, trace_inf f =>
    trace_inf (fun n => if Nat.ltb n (length l) then nth n l (f 0)
                        else f (n - length l))
  | trace_inf f, _ => trace_inf f
  end.

Definition trace_map A B (f : A -> B) (t : trace A) : trace B :=
  match t with
  | trace_fin l => trace_fin (map f l)
  | trace_inf fl => trace_inf (fun x => f (fl x))
  end.

Definition trace_prefix A (t t' : trace A) :=
  match t, t' with
  | trace_fin l, trace_fin l' => exists l'', l' = l ++ l''
  | trace_fin l, trace_inf f => forall i (LLEN: i < length l) d, f i = nth i l d
  | trace_inf f, trace_fin _ => False
  | trace_inf f, trace_inf f' => forall x, f x = f' x
  end.

Lemma trace_prefix_seq A (t t' : trace A) :
  trace_prefix t (trace_seq t t').
Proof.
  destruct t, t'; ins; desf; eauto using nth_indep; done.
Qed.

Lemma trace_prefixE A (t t' : trace A) :
  trace_prefix t t' <-> exists t'', t' = trace_seq t t''.
Proof.
  split; ins; desf; eauto using trace_prefix_seq.
  destruct t, t'; ins; desf; desf.
  - by eexists (trace_fin _).
  - exists (trace_inf (fun x => fl (x + length l))).
    f_equal; extensionality y; desf; eauto.
    f_equal; omega.
  - exists (trace_fin nil); f_equal; extensionality x; eauto.
Qed.

Lemma trace_seqA A (t t' t'' : trace A) :
  trace_seq (trace_seq t t') t'' =
  trace_seq t (trace_seq t' t'').
Proof.
  unfold trace_seq; ins; desf; try now rewrite appA.
  all: f_equal; extensionality x; desf.
  all: rewrite length_app, ?nth_app in *; desf; try omega.
  auto using nth_indep.
  all: f_equal; omega.
Qed.


(** Labelled transition system (LTS) *)

Record LTS (State Label : Type) : Type :=
  { LTS_init : State -> Prop ;
    LTS_final : State -> Prop ;
    LTS_step : State -> Label -> State -> Prop }.

Section LTS_traces.

  Variable State : Type.
  Variable Label : Type.
  Variable lts : LTS State Label.

  (** Traces generated by a labelled transition system *)

  Definition LTS_trace (t : trace Label) :=
    match t with
    | trace_fin l =>
      exists fl', LTS_init lts (fl' 0) /\
                  forall i (LLEN : i < length l) d,
                    LTS_step lts (fl' i) (nth i l d) (fl' (S i))
    | trace_inf fl =>
      exists fl', LTS_init lts (fl' 0) /\
                  forall i, LTS_step lts (fl' i) (fl i) (fl' (S i))
    end.

  Definition LTS_complete_trace (t : trace Label) :=
    match t with
    | trace_fin l =>
      exists fl', LTS_init lts (fl' 0) /\
                  LTS_final lts (fl' 0) /\
                  forall i (LLEN : i < length l) d,
                    LTS_step lts (fl' i) (nth i l d) (fl' (S i))
    | trace_inf fl =>
      exists fl', LTS_init lts (fl' 0) /\
                  forall i, LTS_step lts (fl' i) (fl i) (fl' (S i))
    end.

  Lemma LTS_complete_trace_weaken t :
    LTS_complete_trace t -> LTS_trace t.
  Proof.
    destruct t; ins; desf; eauto.
  Qed.

  Lemma LTS_trace_prefix_closed t t' :
    LTS_trace t' -> trace_prefix t t' -> LTS_trace t.
  Proof.
    destruct t, t'; ins; desf; exists fl'; splits; ins.
    all: specialize (H1 i); rewrite ?length_app in *.
    all: specialize_full H1; try omega.
    all: try rewrite nth_app in *; desf; eauto; try omega.
    rewrite <- H0; ins.
    rewrite H0; ins.
  Qed.

End LTS_traces.
